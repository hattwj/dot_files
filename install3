#!/usr/bin/env ruby

# Recursively symlinks files in a dot_files repository to the home directory
# and creates backups of any files that would be replaced. Directories are created
# if they are missing. Supports an optional parameter to rename target files that
# match a pattern.

require 'optparse'
require 'fileutils'
require 'json'

# Flag to prevent actually symlinking or renaming files
$no_op = false

def backups_dir
  "#{ENV['HOME']}/.config/dot_files/backups/#{File.basename(git_root)}"
end

# Find the git root directory or raise an exception if not a git repository
def git_root
  git_dir = `git rev-parse --show-toplevel`.strip
  raise "Error: not a git repository" if git_dir.empty?

  git_dir
end

def parse_args(args)
  # Define CLI options and parse them
  options = {
    action: :run_installer,
    config_path: "#{git_root}/installer.json",
    no_op: false
  }

  OptionParser.new(args) do |opts|
    opts.banner = "Usage: #{File.basename(__FILE__)} [options]
Symlink dotfiles from the current git repository to the home directory"

    opts.on("-c", "--config PATH", "Specify a config file for installation details") do |p|
      options[:config_path] = p
    end

    opts.on("-n", "--no-op", "") do
      options[:no_op] = true
    end

    opts.on("-l", "--ls", "List extra available packages") do
      options[:action] = :ls_packages
    end

    opts.on_tail("-h", "--help", "Show this message") do
      puts opts
      exit
    end
  end.parse!
  options
end

class Hash
  def fetch_slice(*keys)
    result = {}
    keys.each do |key|
      result[key] = self.fetch(key)
    end
    result
  end
end

# Define CLI colorization config
class String
  def colorize(color_code)
    "\e[#{color_code}m#{self}\e[0m"
  end

  def red
    colorize(31)
  end

  def green
    colorize(32)
  end

  def yellow
    colorize(33)
  end

  def blue
    colorize(34)
  end
end

def log_no_op(msg)
  puts "[#{'good'.green}] #{msg}"
end

def log_create(msg)
  puts "[#{'create'.green}] #{msg}"
end

def log_delete(msg)
  puts "[#{'delete'.red}] #{msg}"
end

def log_rename(msg)
  puts "[#{'rename'.yellow}] #{msg}"
end

def log_symlink(msg)
  puts "[#{'symlink'.blue}] #{msg}"
end

def log_exclude(msg)
  puts "[#{"exclude".yellow}] #{msg}"
end

# Define a method to recursively symlink files from the source to target directory
def symlink_files(src:, dest:, recursive:, exclude: [])
  Dir.foreach(src) do |filename|
    next if filename == '.' || filename == '..'

    source_path = File.join(src, filename)

    if exclude.include?(source_path)
      log_exclude source_path
      return
    end

    target_path = File.join(dest, filename)

    if File.directory?(source_path) && recursive
      # If the filename is a directory, create it if it doesn't exist in the target directory
      unless File.exists?(target_path)
        log_create(target_path)
        Dir.mkdir(target_path) unless $no_op
      end
      # Recursively symlink its contents
      symlink_files(src: source_path, dest: target_path, recursive: recursive, exclude: exclude)
    else
      symlink_path(src: source_path, dest: target_path)
    end
  end
end

def symlink_path(src:, dest:)
  backup_path = File.join(backups_dir, File.basename(src))
  if File.exists?(dest)
    if !File.symlink?(dest)
      log_rename "#{dest} to #{backup_path}"
      File.rename(dest, backup_path) unless $no_op
    else
      if File.readlink(dest) != src
        # If the target file is a symlink, delete it so it can be replaced
        log_delete "symlink #{dest}"
        File.delete(dest) unless $no_op
      else
        log_no_op("symlink #{src} to #{dest}")
        return
      end
    end
  end
  # Create a symlink to the source file in the target directory
  log_symlink "#{src} to #{dest}"
  File.symlink(source_path, dest) unless $no_op
end

def main(args)
  opts = parse_args(args)
  $no_op = opts.fetch(:no_op)

  begin
    # Check if the current directory is a Git repository
    git_root
  rescue StandardError => e
    puts "Error: #{e.message}".red
    exit 1
  end

  unless File.exists?(opts[:config_path])
    puts "Config file not found: #{opts[:config_path]}"
    exit 1
  end

  config_data = File
    .read(opts[:config_path])
    .gsub("{{git_root}}", git_root)
    .gsub("{{home}}", ENV['HOME'])

  config = JSON.parse(config_data, symbolize_names: true)
  # config = default_config.merge(config)

  unless File.exist?(backups_dir)
    log_create(backups_dir)
    FileUtilis.mkdir_p(backups_dir) unless $no_op
  end

  case opts.fetch(:action)
  when :run_installer
    run_installer(config)
  when :list_packages
    list_packages(config)
  end
end

def run_installer(config)
  Array(config[:symlink_recursive]).each do |symlink_opts|
    name = symlink_opts[:name] || symlink_opts[:src]
    symlink_opts[:exclude] = symlink_opts[:exclude] || []
    symlink_opts[:recursive] = true
    puts "\nLinking #{name}"

    # Call the method to symlink all files from the source to target directory
    symlink_files(**symlink_opts.fetch_slice(:src, :dest, :recursive, :exclude))
  end

  Array(config[:symlinks]).each do |symlink_opts|
    name = symlink_opts[:name] || symlink_opts[:src]
    puts "\nLinking #{name}"

    # Call the method to symlink all files from the source to target directory
    symlink_path(**symlink_opts.fetch_slice(:src, :dest))
  end
end

def list_packages(config)

end

if $PROGRAM_NAME == __FILE__
  trap "SIGINT" do
    puts "Exiting..."
    exit 130
  end
  main(ARGV)
end
