#!/usr/bin/env python3
"""
gex-loop - Watch for file changes and sync to remote host with interactive controls

Usage:
  gex-loop [OPTIONS] [username@hostname:./path]

Arguments:
  username@hostname:./path    Remote destination in SSH format
                              - username: Remote user account
                              - hostname: Remote server hostname/IP
                              - path: Destination path on remote (can be relative or absolute)

Options:
  -h, --help                  Show this help message
  -e, --exclude PATTERN       Exclude pattern for rsync (can be used multiple times)
  -s, --skip-push             Skip push syncs (initial push and post-pull push)
  -v, --verbose               Verbose output

Interactive Controls:
  p - Manual PUSH sync to remote
  y - Manual PULL sync from remote
  q - Quit the program
  ? - Show help

Examples:
  gex-loop foo@bar.com:./baz
  gex-loop myuser@dev-server.com:/var/www/app
  gex-loop -e '.git/' -e '*.swp' user@host:./project
  gex-loop -s user@host:./project  # Skip initial push sync

Description:
  Watches the current directory for file changes (modify, create, delete, move)
  and automatically syncs them to the remote destination using rsync over SSH.
  Uses inotifywait for efficient file watching.

  Interactive menu allows manual push/pull operations at any time.

  The --skip-push flag prevents:
    1. Initial push sync at startup
    2. Automatic push sync after manual pull operations
"""

import argparse
import os
import re
import select
import subprocess
import sys
import termios
import tty
from datetime import datetime
from pathlib import Path
from typing import List, Optional


class Colors:
    """ANSI color codes"""
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    CYAN = '\033[0;36m'
    NC = '\033[0m'  # No Color
    BOLD = '\033[1m'


class GexLoop:
    """File watcher with interactive sync controls"""

    def __init__(self, remote_spec: str, exclude_patterns: List[str], skip_push: bool = False, verbose: bool = False):
        self.remote_spec = remote_spec
        self.exclude_patterns = exclude_patterns
        self.skip_push = skip_push
        self.verbose = verbose
        self.local_dir = os.getcwd()
        self.running = True

        # Flag to prevent inotifywait handling during manual syncs
        self.sync_in_progress = False
        self.pending_inotify_output = []

        # Terminal settings for non-blocking input
        self.old_settings = None

    def error(self, message: str) -> None:
        """Print error message"""
        print(f"{Colors.RED}[error]{Colors.NC} {message}", file=sys.stderr)

    def info(self, message: str) -> None:
        """Print info message"""
        print(f"{Colors.BLUE}[info]{Colors.NC} {message}")

    def success(self, message: str) -> None:
        """Print success message"""
        print(f"{Colors.GREEN}[success]{Colors.NC} {message}")

    def debug(self, message: str) -> None:
        """Print debug message if verbose"""
        if self.verbose:
            print(f"{Colors.YELLOW}[debug]{Colors.NC} {message}")

    def parse_remote_spec(self) -> bool:
        """Validate remote specification format"""
        pattern = r'^[^@]+@[^:]+:.+'
        if not re.match(pattern, self.remote_spec):
            self.error("Invalid remote specification format")
            self.error("Expected format: username@hostname:./path")
            self.error(f"Got: {self.remote_spec}")
            return False

        # Extract components for debugging
        username_hostname, path = self.remote_spec.split(':', 1)
        username, hostname = username_hostname.split('@', 1)

        if not username or not hostname or not path:
            self.error("Remote specification is missing required components")
            return False

        self.debug("Parsed remote specification:")
        self.debug(f"  Username: {username}")
        self.debug(f"  Hostname: {hostname}")
        self.debug(f"  Path: {path}")

        return True

    def check_dependencies(self) -> bool:
        """Check if required commands are available"""
        commands = ['inotifywait', 'rsync']
        missing = []

        for cmd in commands:
            if not self.command_exists(cmd):
                missing.append(cmd)

        if missing:
            self.error(f"Missing required commands: {', '.join(missing)}")
            self.error("Install with: sudo apt-get install inotify-tools rsync")
            return False

        return True

    @staticmethod
    def command_exists(command: str) -> bool:
        """Check if a command exists"""
        return subprocess.run(
            ['which', command],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        ).returncode == 0

    def build_rsync_args(self, delete: bool = False) -> List[str]:
        """Build rsync command arguments"""
        args = ['rsync', '-avze', 'ssh']

        if delete:
            args.append('--delete')

        for pattern in self.exclude_patterns:
            args.extend(['--exclude', pattern])

        if self.verbose:
            args.append('--progress')

        return args

    def rsync_push(self, delete: bool = False) -> bool:
        """Push local changes to remote"""
        args = self.build_rsync_args(delete=delete)
        args.extend(['./', self.remote_spec])

        self.debug(f"Running: {' '.join(args)}")

        try:
            result = subprocess.run(args, check=False)
            return result.returncode == 0
        except Exception as e:
            self.error(f"Push sync failed: {e}")
            return False

    def rsync_pull(self) -> bool:
        """Pull remote changes to local"""
        args = self.build_rsync_args(delete=False)
        args.extend([self.remote_spec, './'])

        self.debug(f"Running: {' '.join(args)}")

        try:
            result = subprocess.run(args, check=False)
            return result.returncode == 0
        except Exception as e:
            self.error(f"Pull sync failed: {e}")
            return False

    def initial_sync(self) -> None:
        """Perform initial push sync if not skipped"""
        if self.skip_push:
            self.info("Skipping initial push sync (--skip-push enabled)")
            return

        self.info("Performing initial push sync...")
        if self.rsync_push():
            self.success("Initial sync completed")
        else:
            self.error("Initial push sync failed")
            self.error("Continuing anyway - use manual push (p) if needed")

    def show_menu(self) -> None:
        """Display interactive menu"""
        print(f"\n{Colors.CYAN}{'='*60}{Colors.NC}")
        print(f"{Colors.BOLD}Interactive Controls:{Colors.NC}")
        print(f"  {Colors.GREEN}p{Colors.NC} - Manual PUSH sync to remote")
        print(f"  {Colors.GREEN}y{Colors.NC} - Manual PULL sync from remote")
        print(f"  {Colors.GREEN}q{Colors.NC} - Quit the program")
        print(f"  {Colors.GREEN}?{Colors.NC} - Show this help")
        print(f"{Colors.CYAN}{'='*60}{Colors.NC}\n")

    def setup_terminal(self) -> None:
        """Setup terminal for non-blocking input"""
        if sys.stdin.isatty():
            self.old_settings = termios.tcgetattr(sys.stdin)
            tty.setcbreak(sys.stdin.fileno())

    def restore_terminal(self) -> None:
        """Restore terminal settings"""
        if self.old_settings:
            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, self.old_settings)

    def get_keypress(self, timeout: float = 0.1) -> Optional[str]:
        """Get a keypress without blocking (non-blocking with timeout)"""
        if not sys.stdin.isatty():
            return None

        rlist, _, _ = select.select([sys.stdin], [], [], timeout)
        if rlist:
            return sys.stdin.read(1)
        return None

    def drain_inotify_output(self, process) -> None:
        """Drain any pending inotifywait output to prevent stale events"""
        if process.poll() is not None:
            return

        # Clear pending output buffer
        self.pending_inotify_output.clear()

        # Read and discard any pending output
        while True:
            rlist, _, _ = select.select([process.stdout], [], [], 0.0)
            if not rlist:
                break
            line = process.stdout.readline()
            if not line:
                break
            self.debug(f"Drained inotify event: {line.strip()}")

    def handle_keypress(self, key: str) -> None:
        """Handle user keypress"""
        if key == 'p':
            self.sync_in_progress = True
            print(f"\n{Colors.YELLOW}[manual]{Colors.NC} Triggering manual PUSH sync...")
            if self.rsync_push(delete=True):
                self.success(f"Manual push completed at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            else:
                self.error("Manual push failed")
            self.sync_in_progress = False

        elif key == 'y':
            self.sync_in_progress = True
            print(f"\n{Colors.YELLOW}[manual]{Colors.NC} Triggering manual PULL sync...")
            if self.rsync_pull():
                self.success(f"Manual pull completed at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

                # Optionally push after pull unless --skip-push is set
                if not self.skip_push:
                    print(f"{Colors.YELLOW}[auto]{Colors.NC} Pushing local changes after pull...")
                    if self.rsync_push(delete=True):
                        self.success("Post-pull push completed")
                    else:
                        self.error("Post-pull push failed")
                else:
                    self.debug("Skipping post-pull push (--skip-push enabled)")
            else:
                self.error("Manual pull failed")
            self.sync_in_progress = False

        elif key == 'q':
            print(f"\n{Colors.YELLOW}[info]{Colors.NC} Quitting...")
            self.running = False

        elif key == '?':
            self.show_menu()

    def watch_and_sync(self, inotify_process=None) -> None:
        """Main watch loop with inotifywait"""
        # Start inotifywait process
        inotify_cmd = [
            'inotifywait',
            '-r',  # Recursive
            '-m',  # Monitor mode (don't exit after first event)
            '-e', 'modify,create,delete,move',
            '.'
        ]

        self.info("Watching for changes... (Press 'p' to push, 'y' to pull, 'q' to quit, '?' for help)")
        self.show_menu()

        try:
            # Start inotifywait in background
            process = subprocess.Popen(
                inotify_cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1
            )

            self.setup_terminal()

            while self.running:
                # Check for keypresses
                key = self.get_keypress(timeout=0.1)
                if key:
                    # Store the process reference for draining
                    old_sync_state = self.sync_in_progress
                    self.handle_keypress(key)
                    # If we just completed a sync, drain pending inotify events
                    if old_sync_state != self.sync_in_progress and not self.sync_in_progress:
                        self.drain_inotify_output(process)

                # Check for inotify events
                if process.poll() is not None:
                    self.error("inotifywait process died unexpectedly")
                    break

                # Check if there's output from inotifywait (file change detected)
                # Skip processing if a manual sync is in progress
                if self.sync_in_progress:
                    continue

                rlist, _, _ = select.select([process.stdout], [], [], 0.1)
                if rlist:
                    line = process.stdout.readline()
                    if line and len(line) > 0 and 'Setting up watches' not in line and 'Watches established.' not in line:
                        # File change detected
                        print()
                        self.info(f"line -- {len(line)} -- '{repr(line)}'")
                        self.sync_in_progress = True
                        self.info("Changes detected, auto-syncing...")
                        if self.rsync_push(delete=True):
                            self.success(f"Auto-sync completed at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
                        else:
                            self.error("Auto-sync failed")
                        self.sync_in_progress = False

                        # Drain any inotify events that accumulated during sync
                        # This prevents rsync operations from triggering another auto-sync
                        self.drain_inotify_output(process)

                        self.show_menu()

        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}[info]{Colors.NC} Interrupted by user")

        finally:
            self.restore_terminal()
            if process.poll() is None:
                process.terminate()
                process.wait()

    def run(self) -> int:
        """Main entry point"""
        # Validate configuration
        if not self.parse_remote_spec():
            return 1

        if not self.check_dependencies():
            return 1

        # Show configuration
        self.info("Starting gex-loop file watcher")
        self.info(f"Local directory: {self.local_dir}")
        self.info(f"Remote destination: {self.remote_spec}")

        if self.skip_push:
            self.info(f"{Colors.YELLOW}Skip-push mode enabled{Colors.NC} - no automatic push syncs")

        if self.verbose:
            self.debug(f"Exclude patterns: {', '.join(self.exclude_patterns)}")

        # Initial sync (skipped if --skip-push)
        self.initial_sync()

        # Start watching
        self.watch_and_sync()

        return 0


def main():
    """Main function"""
    parser = argparse.ArgumentParser(
        description='Watch for file changes and sync to remote host with interactive controls',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Interactive Controls:
  p - Manual PUSH sync to remote
  y - Manual PULL sync from remote
  q - Quit the program
  ? - Show help

Examples:
  gex-loop foo@bar.com:./baz
  gex-loop myuser@dev-server.com:/var/www/app
  gex-loop -e '.git/' -e '*.swp' user@host:./project
  gex-loop -s user@host:./project  # Skip initial and post-pull push syncs
        """
    )

    parser.add_argument(
        'remote_spec',
        help='Remote destination in format username@hostname:./path'
    )

    parser.add_argument(
        '-e', '--exclude',
        action='append',
        dest='exclude_patterns',
        default=[],
        help='Exclude pattern for rsync (can be used multiple times)'
    )

    parser.add_argument(
        '-s', '--skip-push',
        action='store_true',
        help='Skip push syncs (initial push at startup and post-pull push)'
    )

    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Verbose output'
    )

    args = parser.parse_args()

    # Validate remote spec ends with /
    if not args.remote_spec.endswith('/'):
        print(f"{Colors.RED}[error]{Colors.NC} Remote destination must end with '/' (important for rsync)", file=sys.stderr)
        return 1

    # Add default .git/ exclusion if no exclusions specified
    if not args.exclude_patterns:
        args.exclude_patterns = ['.git/']

    # Create and run
    gex = GexLoop(
        remote_spec=args.remote_spec,
        exclude_patterns=args.exclude_patterns,
        skip_push=args.skip_push,
        verbose=args.verbose
    )

    return gex.run()


if __name__ == '__main__':
    sys.exit(main())
