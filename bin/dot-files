#!/usr/bin/env python3
"""
dot-files - Comprehensive dot-files management across multiple repositories

A sophisticated tool for managing dotfile configurations with intelligent path detection,
symlink management, and bidirectional synchronization capabilities.

Usage:
    dot-files add <file_path> [<repo_path>]     - Add file to dot-files repo
    dot-files remove <file_path> [<repo_path>]  - Remove file from dot-files repo
    dot-files status [<repo_path>]              - Show synchronization status
    dot-files clean [<repo_path>]               - Clean broken symlinks
    dot-files install [<repo_path>]             - Install symlinks to home directory

Examples:
    dot-files add ~/.vimrc                      - Add .vimrc from current git repo
    dot-files add ~/.vimrc ~/my-dotfiles/       - Add .vimrc to specific repo
    dot-files status                            - Check status in current git repo
    dot-files clean ~/universal-dotfiles/       - Clean broken links in specific repo
    dot-files install                           - Install from current git repo
"""

import os
import sys
import argparse
import subprocess
import shutil
from pathlib import Path
from typing import Optional, List, Tuple, Dict, Set
import json
import tempfile
from datetime import datetime


class Colors:
    """ANSI color codes for terminal output"""
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    MAGENTA = '\033[0;35m'
    CYAN = '\033[0;36m'
    WHITE = '\033[1;37m'
    NC = '\033[0m'  # No Color
    BOLD = '\033[1m'


class DotfilesManager:
    """Main class for managing dot-files operations"""

    def __init__(self, verbose: bool = False, dry_run: bool = False):
        self.verbose = verbose
        self.dry_run = dry_run
        # Properly expand $HOME environment variable to handle non-standard home paths
        home_env = os.environ.get('HOME')
        self.home_dir = Path(home_env).resolve() if home_env else Path.home()
        self.log_info(f"Using home directory: {self.home_dir}", force=False)
        self.configs_subdir = "configs"  # Standard subdirectory in dot-files repos

    def log_info(self, message: str, force: bool = False):
        """Print info message"""
        if self.verbose or force:
            print(f"{Colors.BLUE}[INFO]{Colors.NC} {message}")

    def log_success(self, message: str):
        """Print success message"""
        print(f"{Colors.GREEN}[SUCCESS]{Colors.NC} {message}")

    def log_warning(self, message: str):
        """Print warning message"""
        print(f"{Colors.YELLOW}[WARNING]{Colors.NC} {message}")

    def log_error(self, message: str):
        """Print error message"""
        print(f"{Colors.RED}[ERROR]{Colors.NC} {message}")

    def log_dry_run(self, message: str):
        """Print dry run action"""
        if self.dry_run:
            print(f"{Colors.CYAN}[DRY RUN]{Colors.NC} {message}")

    def get_git_root(self, path: Optional[Path] = None) -> Optional[Path]:
        """Get git repository root from given path or current directory"""
        if path is None:
            path = Path.cwd()
        else:
            path = Path(path).resolve()

        try:
            # Check if we're in a git repository
            result = subprocess.run(
                ["git", "rev-parse", "--is-inside-work-tree"],
                cwd=path,
                capture_output=True,
                text=True,
                check=True
            )

            if result.returncode == 0:
                # Get the repository root
                result = subprocess.run(
                    ["git", "rev-parse", "--show-toplevel"],
                    cwd=path,
                    capture_output=True,
                    text=True,
                    check=True
                )

                if result.returncode == 0 and result.stdout.strip():
                    return Path(result.stdout.strip())

        except (subprocess.CalledProcessError, FileNotFoundError):
            pass

        return None

    def validate_repo_path(self, repo_path: Path) -> Tuple[bool, Path]:
        """
        Validate repository path and suggest corrections
        Returns (is_valid, corrected_path)
        """
        repo_path = repo_path.resolve()

        # Check if it's a git repository root
        git_root = self.get_git_root(repo_path)

        if git_root is None:
            self.log_error(f"Path {repo_path} is not within a git repository")
            return False, repo_path

        if git_root != repo_path:
            self.log_warning(f"Path {repo_path} is not the git repository root")
            self.log_warning(f"Git root is: {git_root}")

            # Ask user for confirmation or correction
            response = input(f"Use git root {git_root} instead? [Y/n]: ").strip().lower()
            if response in ('', 'y', 'yes'):
                return True, git_root
            else:
                return False, repo_path

        return True, repo_path

    def resolve_repo_path(self, repo_path: Optional[str] = None) -> Optional[Path]:
        """
        Resolve repository path with intelligent detection
        """
        if repo_path:
            # Explicit repo path provided
            path = Path(repo_path).expanduser().resolve()
            is_valid, corrected_path = self.validate_repo_path(path)
            return corrected_path if is_valid else None
        else:
            # Try to detect from current working directory
            git_root = self.get_git_root()
            if git_root:
                self.log_info(f"Auto-detected git repository: {git_root}")
                return git_root
            else:
                self.log_error("No repository path provided and current directory is not a git repository")
                self.log_error("Please specify a dot-files repository path or run from within a git repository")
                return None

    def get_relative_path_from_home(self, file_path: Path) -> Optional[Path]:
        """
        Get relative path from home directory
        Returns None if file is not under home directory
        """
        try:
            file_path = file_path.resolve()
            return file_path.relative_to(self.home_dir)
        except ValueError:
            return None

    def get_dotfiles_config_path(self, repo_path: Path, relative_home_path: Path) -> Path:
        """
        Get the corresponding path in dot-files repository configs directory
        """
        return repo_path / self.configs_subdir / relative_home_path

    def get_home_path_from_config(self, config_path: Path, repo_path: Path) -> Path:
        """
        Get home directory path from dot-files config path
        """
        relative_path = config_path.relative_to(repo_path / self.configs_subdir)
        return self.home_dir / relative_path

    def is_symlink_to_config(self, home_path: Path, config_path: Path) -> bool:
        """
        Check if home_path is a symlink pointing to config_path
        """
        if not home_path.is_symlink():
            return False

        try:
            return home_path.resolve() == config_path.resolve()
        except (OSError, RuntimeError):
            return False

    def scan_dotfiles_config(self, repo_path: Path) -> List[Path]:
        """
        Scan dot-files repository configs directory for all files
        """
        config_dir = repo_path / self.configs_subdir
        if not config_dir.exists():
            return []

        files = []
        for item in config_dir.rglob('*'):
            if item.is_file():
                files.append(item)

        return files

    def get_scan_dirs_from_config(self, repo_path: Path) -> List[Path]:
        """
        Build a list of directories in $HOME to scan based on ./configs structure.
        For each top-level item in ./configs, return the corresponding $HOME path.
        """
        config_dir = repo_path / self.configs_subdir
        if not config_dir.exists():
            return []

        scan_paths = []

        # Get only the top-level items in configs directory
        for item in config_dir.iterdir():
            try:
                # Get the relative path from configs directory
                relative_path = item.relative_to(config_dir)
                # Calculate corresponding home path
                home_path = self.home_dir / relative_path

                # Add the path if it exists (we'll scan it recursively if it's a dir)
                if home_path.exists():
                    scan_paths.append(home_path)
                    self.log_info(f"Will scan: {home_path}", force=False)
            except ValueError:
                continue

        return scan_paths

    def scan_broken_symlinks_in_home(self, repo_path: Path) -> List[Path]:
        """
        Scan directories/files in home directory for broken symlinks.
        Uses the ./configs directory structure to determine what to scan.
        If ./configs contains a directory, recursively scans the corresponding $HOME directory.
        If ./configs contains a file, checks the corresponding $HOME file.
        """
        broken_links = []

        # Get the directories/files to scan based on ./configs structure
        scan_paths = self.get_scan_dirs_from_config(repo_path)

        self.log_info(f"Scanning {len(scan_paths)} top-level paths based on ./configs")

        for scan_path in scan_paths:
            if scan_path.is_dir():
                # Recursively scan directories
                self.log_info(f"Recursively scanning directory: {scan_path}", force=False)
                try:
                    for item in scan_path.rglob('*'):
                        if item.is_symlink() and not item.exists():
                            broken_links.append(item)
                except (PermissionError, OSError) as e:
                    self.log_warning(f"Cannot scan {scan_path}: {e}")
            elif scan_path.is_symlink():
                # Check if single file symlink is broken
                try:
                    if not scan_path.exists():
                        broken_links.append(scan_path)
                except (OSError, RuntimeError):
                    broken_links.append(scan_path)

        return broken_links

    def create_symlink(self, target: Path, link_path: Path) -> bool:
        """
        Create symlink safely, backing up existing files if necessary
        """
        link_path = link_path.resolve()
        target = target.resolve()

        if link_path.exists() or link_path.is_symlink():
            if link_path.is_symlink():
                current_target = link_path.resolve() if link_path.exists() else None
                if current_target == target:
                    self.log_info(f"Symlink already exists: {link_path} -> {target}")
                    return True
                else:
                    self.log_warning(f"Symlink exists but points to different target: {link_path}")
                    response = input("Replace existing symlink? [y/N]: ").strip().lower()
                    if response not in ('y', 'yes'):
                        return False
            else:
                self.log_warning(f"File exists at {link_path}")
                response = input("Backup existing file and create symlink? [y/N]: ").strip().lower()
                if response not in ('y', 'yes'):
                    return False

                # Create backup
                backup_path = Path(str(link_path) + f'.backup.{datetime.now().strftime("%Y%m%d_%H%M%S")}')
                if not self.dry_run:
                    shutil.move(str(link_path), str(backup_path))
                self.log_info(f"Backed up existing file to: {backup_path}")

        # Create parent directories if needed
        link_path.parent.mkdir(parents=True, exist_ok=True)

        if not self.dry_run:
            if link_path.exists() or link_path.is_symlink():
                link_path.unlink()
            link_path.symlink_to(target)

        self.log_dry_run(f"Would create symlink: {link_path} -> {target}")
        if not self.dry_run:
            self.log_success(f"Created symlink: {link_path} -> {target}")

        return True

    def copy_file_to_config(self, source: Path, destination: Path) -> bool:
        """
        Copy file from home directory to dot-files config directory
        """
        source = source.resolve()
        destination = destination.resolve()

        if not source.exists():
            self.log_error(f"Source file does not exist: {source}")
            return False

        if destination.exists():
            self.log_warning(f"Destination file already exists: {destination}")
            response = input("Overwrite existing file? [y/N]: ").strip().lower()
            if response not in ('y', 'yes'):
                return False

        # Create parent directories
        destination.parent.mkdir(parents=True, exist_ok=True)

        if not self.dry_run:
            shutil.copy2(str(source), str(destination))

        self.log_dry_run(f"Would copy: {source} -> {destination}")
        if not self.dry_run:
            self.log_success(f"Copied file: {source} -> {destination}")

        return True

    def cmd_add(self, args) -> int:
        """
        Add a file to dot-files repository
        """
        file_path = Path(args.file_path).expanduser().resolve()

        if not file_path.exists():
            self.log_error(f"File does not exist: {file_path}")
            return 1

        # Resolve repository path
        repo_path = self.resolve_repo_path(args.repo_path)
        if not repo_path:
            return 1

        # Check if file is under home directory
        relative_home_path = self.get_relative_path_from_home(file_path)
        if relative_home_path is None:
            self.log_error(f"File {file_path} is not under home directory {self.home_dir}")
            return 1

        # Get destination path in dot-files repo
        config_path = self.get_dotfiles_config_path(repo_path, relative_home_path)

        self.log_info(f"Adding file: {file_path}")
        self.log_info(f"Repository: {repo_path}")
        self.log_info(f"Config path: {config_path}")

        # Copy file to dot-files repository
        if not self.copy_file_to_config(file_path, config_path):
            return 1

        # Create symlink from home to dot-files
        if not self.create_symlink(config_path, file_path):
            self.log_warning("File copied but symlink creation failed")
            return 1

        self.log_success(f"Successfully added {relative_home_path} to dot-files repository")
        return 0

    def cmd_remove(self, args) -> int:
        """
        Remove a file from dot-files repository
        """
        file_path = Path(args.file_path).expanduser().resolve()

        # Resolve repository path
        repo_path = self.resolve_repo_path(args.repo_path)
        if not repo_path:
            return 1

        # Get relative path from home
        relative_home_path = self.get_relative_path_from_home(file_path)
        if relative_home_path is None:
            self.log_error(f"File {file_path} is not under home directory {self.home_dir}")
            return 1

        # Get config path
        config_path = self.get_dotfiles_config_path(repo_path, relative_home_path)

        self.log_info(f"Removing file: {relative_home_path}")
        self.log_info(f"Repository: {repo_path}")
        self.log_info(f"Config path: {config_path}")

        # Check if config file exists
        if not config_path.exists():
            self.log_error(f"File not found in dot-files repository: {config_path}")
            return 1

        # Remove from dot-files repository
        if not self.dry_run:
            config_path.unlink()
        self.log_dry_run(f"Would remove: {config_path}")
        if not self.dry_run:
            self.log_success(f"Removed from repository: {config_path}")

        # Handle symlink in home directory
        if file_path.is_symlink():
            if self.is_symlink_to_config(file_path, config_path):
                if not self.dry_run:
                    file_path.unlink()
                self.log_dry_run(f"Would remove symlink: {file_path}")
                if not self.dry_run:
                    self.log_success(f"Removed symlink: {file_path}")
            else:
                self.log_warning(f"Symlink exists but doesn't point to dot-files: {file_path}")
        elif file_path.exists():
            self.log_warning(f"Regular file exists in home directory: {file_path}")
            self.log_warning("Consider backing up or removing it manually")

        return 0

    def cmd_status(self, args) -> int:
        """
        Show synchronization status between home directory and dot-files repository
        """
        # Resolve repository path
        repo_path = self.resolve_repo_path(args.repo_path)
        if not repo_path:
            return 1

        config_dir = repo_path / self.configs_subdir

        print(f"\n{Colors.BOLD}Dot-files Status Report{Colors.NC}")
        print(f"Repository: {repo_path}")
        print(f"Config directory: {config_dir}")
        print("=" * 60)

        if not config_dir.exists():
            self.log_warning(f"Config directory does not exist: {config_dir}")
            return 1

        # Scan dot-files repository
        config_files = self.scan_dotfiles_config(repo_path)

        unlinked_configs = []
        broken_symlinks = []
        good_symlinks = []
        home_files_without_configs = []

        print(f"\n{Colors.CYAN}Checking files in dot-files repository...{Colors.NC}")

        for config_file in config_files:
            relative_path = config_file.relative_to(repo_path / self.configs_subdir)
            home_path = self.home_dir / relative_path

            if home_path.exists():
                if home_path.is_symlink():
                    if self.is_symlink_to_config(home_path, config_file):
                        good_symlinks.append((relative_path, config_file, home_path))
                        if self.verbose:
                            print(f"  ✓ {Colors.GREEN}{relative_path}{Colors.NC}")
                    else:
                        print(f"  ⚠ {Colors.YELLOW}{relative_path}{Colors.NC} - symlink points elsewhere")
                else:
                    unlinked_configs.append((relative_path, config_file, home_path))
                    print(f"  ⚠ {Colors.YELLOW}{relative_path}{Colors.NC} - regular file exists")
            else:
                unlinked_configs.append((relative_path, config_file, home_path))
                print(f"  ✗ {Colors.RED}{relative_path}{Colors.NC} - no symlink")

        # Check for broken symlinks in home directory
        print(f"\n{Colors.CYAN}Checking for broken symlinks in home directory...{Colors.NC}")
        broken_home_symlinks = self.scan_broken_symlinks_in_home(repo_path)

        for broken_link in broken_home_symlinks:
            try:
                relative_path = broken_link.relative_to(self.home_dir)
                print(f"  ✗ {Colors.RED}{relative_path}{Colors.NC} - broken symlink")
            except ValueError:
                continue  # Not under home directory

        # Summary
        print(f"\n{Colors.BOLD}Summary:{Colors.NC}")
        print(f"  Good symlinks: {Colors.GREEN}{len(good_symlinks)}{Colors.NC}")
        print(f"  Unlinked configs: {Colors.YELLOW}{len(unlinked_configs)}{Colors.NC}")
        print(f"  Broken symlinks: {Colors.RED}{len(broken_symlinks) + len(broken_home_symlinks)}{Colors.NC}")

        if unlinked_configs or broken_symlinks or broken_home_symlinks:
            print(f"\n{Colors.YELLOW}Run 'dot-files install' to create missing symlinks{Colors.NC}")
            print(f"{Colors.YELLOW}Run 'dot-files clean' to remove broken symlinks{Colors.NC}")

        return 0

    def cmd_clean(self, args) -> int:
        """
        Clean broken symlinks in both home directory and dot-files repository
        """
        # Resolve repository path
        repo_path = self.resolve_repo_path(args.repo_path)
        if not repo_path:
            return 1

        print(f"\n{Colors.BOLD}Cleaning broken symlinks{Colors.NC}")
        print(f"Repository: {repo_path}")

        cleaned_count = 0

        # Find broken symlinks in home directory
        broken_home_symlinks = self.scan_broken_symlinks_in_home(repo_path)

        if broken_home_symlinks:
            print(f"\n{Colors.CYAN}Cleaning broken symlinks in home directory...{Colors.NC}")

            for broken_link in broken_home_symlinks:
                try:
                    relative_path = broken_link.relative_to(self.home_dir)
                    print(f"  Removing: {Colors.RED}{relative_path}{Colors.NC}")

                    if not self.dry_run:
                        broken_link.unlink()
                    else:
                        self.log_dry_run(f"Would remove: {broken_link}")

                    cleaned_count += 1

                except ValueError:
                    continue  # Not under home directory
                except OSError as e:
                    self.log_error(f"Failed to remove {broken_link}: {e}")

        # Check for orphaned configs (configs without corresponding home files)
        config_files = self.scan_dotfiles_config(repo_path)
        orphaned_configs = []

        for config_file in config_files:
            relative_path = config_file.relative_to(repo_path / self.configs_subdir)
            home_path = self.home_dir / relative_path

            if not home_path.exists() and not home_path.is_symlink():
                orphaned_configs.append((relative_path, config_file))

        if orphaned_configs:
            print(f"\n{Colors.CYAN}Found orphaned config files (no corresponding home files):{Colors.NC}")
            for relative_path, config_file in orphaned_configs:
                print(f"  {Colors.YELLOW}{relative_path}{Colors.NC}")

            if not args.force:
                response = input("\nRemove orphaned config files? [y/N]: ").strip().lower()
                if response not in ('y', 'yes'):
                    print("Skipping orphaned config cleanup")
                else:
                    for relative_path, config_file in orphaned_configs:
                        if not self.dry_run:
                            config_file.unlink()
                        else:
                            self.log_dry_run(f"Would remove: {config_file}")
                        print(f"  Removed: {Colors.RED}{relative_path}{Colors.NC}")
                        cleaned_count += 1

        if cleaned_count > 0:
            self.log_success(f"Cleaned {cleaned_count} broken/orphaned items")
        else:
            self.log_info("No broken symlinks found")

        return 0

    def cmd_install(self, args) -> int:
        """
        Install symlinks from dot-files repository to home directory
        """
        # Resolve repository path
        repo_path = self.resolve_repo_path(args.repo_path)
        if not repo_path:
            return 1

        config_dir = repo_path / self.configs_subdir

        if not config_dir.exists():
            self.log_error(f"Config directory does not exist: {config_dir}")
            return 1

        print(f"\n{Colors.BOLD}Installing symlinks from dot-files repository{Colors.NC}")
        print(f"Repository: {repo_path}")
        print(f"Config directory: {config_dir}")

        # Scan dot-files repository
        config_files = self.scan_dotfiles_config(repo_path)

        if not config_files:
            self.log_warning("No configuration files found in repository")
            return 0

        installed_count = 0
        skipped_count = 0

        for config_file in config_files:
            relative_path = config_file.relative_to(repo_path / self.configs_subdir)
            home_path = self.home_dir / relative_path

            # Check current state
            if home_path.exists() or home_path.is_symlink():
                if home_path.is_symlink() and self.is_symlink_to_config(home_path, config_file):
                    if self.verbose:
                        print(f"  ✓ Already linked: {Colors.GREEN}{relative_path}{Colors.NC}")
                    skipped_count += 1
                    continue

            print(f"  Installing: {Colors.BLUE}{relative_path}{Colors.NC}")

            if self.create_symlink(config_file, home_path):
                installed_count += 1
            else:
                skipped_count += 1

        print(f"\n{Colors.BOLD}Installation Summary:{Colors.NC}")
        print(f"  Installed: {Colors.GREEN}{installed_count}{Colors.NC}")
        print(f"  Skipped: {Colors.YELLOW}{skipped_count}{Colors.NC}")

        if installed_count > 0:
            self.log_success(f"Successfully installed {installed_count} symlinks")

        return 0


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description="Comprehensive dot-files management across multiple repositories",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  dot-files add ~/.vimrc                      - Add .vimrc from current git repo
  dot-files add ~/.vimrc ~/my-dotfiles/       - Add .vimrc to specific repo
  dot-files remove ~/.bashrc                  - Remove .bashrc from current repo
  dot-files status                            - Check status in current git repo
  dot-files status ~/universal-dotfiles/      - Check status in specific repo
  dot-files clean ~/dotfiles/                 - Clean broken links in specific repo
  dot-files install                           - Install from current git repo

Repository Detection:
  - If no repository path is provided, the tool will auto-detect the git repository
    root from the current working directory
  - If a repository path is provided but points to a subdirectory of a git repo,
    the tool will warn and offer to use the git root instead
  - The tool expects configuration files to be in a 'configs' subdirectory

File Management:
  - Files are copied to <repo>/configs/<relative-path-from-home>
  - Symlinks are created from home directory to the repository files
  - Bidirectional scanning detects unlinked files and broken symlinks
  - Safe handling of existing files with backup options
"""
    )

    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        help='Enable verbose output'
    )

    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Show what would be done without making changes'
    )

    # Create subparsers for commands
    subparsers = parser.add_subparsers(dest='command', help='Available commands')

    # Add command
    add_parser = subparsers.add_parser('add', help='Add file to dot-files repository')
    add_parser.add_argument('file_path', help='Path to file to add')
    add_parser.add_argument('repo_path', nargs='?', help='Dot-files repository path (optional)')

    # Remove command
    remove_parser = subparsers.add_parser('remove', help='Remove file from dot-files repository')
    remove_parser.add_argument('file_path', help='Path to file to remove')
    remove_parser.add_argument('repo_path', nargs='?', help='Dot-files repository path (optional)')

    # Status command
    status_parser = subparsers.add_parser('status', help='Show synchronization status')
    status_parser.add_argument('repo_path', nargs='?', help='Dot-files repository path (optional)')

    # Clean command
    clean_parser = subparsers.add_parser('clean', help='Clean broken symlinks')
    clean_parser.add_argument('repo_path', nargs='?', help='Dot-files repository path (optional)')
    clean_parser.add_argument('--force', action='store_true', help='Remove orphaned configs without confirmation')

    # Install command
    install_parser = subparsers.add_parser('install', help='Install symlinks to home directory')
    install_parser.add_argument('repo_path', nargs='?', help='Dot-files repository path (optional)')

    # Parse arguments
    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return 1

    # Create manager
    manager = DotfilesManager(verbose=args.verbose, dry_run=args.dry_run)

    # Execute command
    try:
        if args.command == 'add':
            return manager.cmd_add(args)
        elif args.command == 'remove':
            return manager.cmd_remove(args)
        elif args.command == 'status':
            return manager.cmd_status(args)
        elif args.command == 'clean':
            return manager.cmd_clean(args)
        elif args.command == 'install':
            return manager.cmd_install(args)
        else:
            parser.print_help()
            return 1

    except KeyboardInterrupt:
        print(f"\n{Colors.YELLOW}Operation cancelled by user{Colors.NC}")
        return 130
    except Exception as e:
        print(f"{Colors.RED}[ERROR]{Colors.NC} Unexpected error: {e}")
        if manager.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == "__main__":
    sys.exit(main())
