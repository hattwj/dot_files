#!/usr/bin/env python3
"""
tee-wrap - A generic command wrapper that logs interactive sessions to organized
markdown files while preserving full interactivity and user experience.

Usage: tee-wrap [OPTIONS] -- COMMAND [ARGS...]
"""

import os
import sys
import subprocess
import pty
import select
import signal
import tempfile
import shutil
import argparse
from pathlib import Path
from datetime import datetime
import re


class Colors:
    """ANSI color codes for terminal output"""
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    NC = '\033[0m'  # No Color


class LineBuffer:
    """Buffer for handling carriage return overwrites in terminal output"""

    def __init__(self):
        self.current_line = ""
        self.completed_lines = []

    def add_data(self, data):
        """Add data to buffer, handling carriage returns properly"""
        for char in data:
            if char == '\r':
                # Carriage return - reset current line (overwrite behavior)
                self.current_line = ""
            elif char == '\n':
                # Newline - complete current line
                if self.current_line.strip():  # Only keep non-empty lines
                    self.completed_lines.append(self.current_line)
                self.current_line = ""
            else:
                # Regular character - add to current line
                self.current_line += char

    def flush_current_line(self):
        """Flush current line to completed lines (called on program exit)"""
        if self.current_line.strip():
            self.completed_lines.append(self.current_line)
            self.current_line = ""

    def get_completed_lines(self):
        """Get all completed lines"""
        return self.completed_lines.copy()

    def clear(self):
        """Clear all lines"""
        self.current_line = ""
        self.completed_lines = []


class CommandLogger:
    """Main class for managing command session logging"""

    def __init__(self, log_base=None, repo_name=None, log_prefix="session"):
        self.log_base = Path(log_base) if log_base else Path.home() / ".tee-wrap"
        self.repo_name = repo_name
        self.log_prefix = log_prefix
        self.log_dir = None
        self.log_file = None
        self.temp_files = []
        self.line_buffer = LineBuffer()

    def log_info(self, message):
        """Print info message to stderr"""
        print(f"{Colors.BLUE}[INFO]{Colors.NC} {message}", file=sys.stderr)

    def log_warn(self, message):
        """Print warning message to stderr"""
        print(f"{Colors.YELLOW}[WARN]{Colors.NC} {message}", file=sys.stderr)

    def log_error(self, message):
        """Print error message to stderr"""
        print(f"{Colors.RED}[ERROR]{Colors.NC} {message}", file=sys.stderr)

    def log_success(self, message):
        """Print success message to stderr"""
        print(f"{Colors.GREEN}[SUCCESS]{Colors.NC} {message}", file=sys.stderr)

    def get_repo_name(self):
        """Get git repository name with fallback strategies"""
        if self.repo_name:
            return self.repo_name

        try:
            # Try to get git repository root
            result = subprocess.run(
                ["git", "rev-parse", "--is-inside-work-tree"],
                capture_output=True,
                text=True,
                check=True
            )

            if result.returncode == 0:
                result = subprocess.run(
                    ["git", "rev-parse", "--show-toplevel"],
                    capture_output=True,
                    text=True,
                    check=True
                )

                if result.returncode == 0 and result.stdout.strip():
                    git_root = Path(result.stdout.strip())
                    repo_name = git_root.name
                    if repo_name:
                        self.repo_name = self._sanitize_name(repo_name)
                        return self.repo_name

        except (subprocess.CalledProcessError, FileNotFoundError):
            pass

        # Fallback strategies
        if not self.repo_name:
            # Try current directory name
            current_dir = Path.cwd().name
            if current_dir and current_dir != ".":
                self.repo_name = self._sanitize_name(current_dir)
                self.log_warn(f"Not in a git repository, using current directory name: {self.repo_name}")
            else:
                # Final fallback
                self.repo_name = f"unknown-{int(datetime.now().timestamp())}"
                self.log_warn(f"Unable to determine repository name, using: {self.repo_name}")

        return self.repo_name

    def _sanitize_name(self, name):
        """Sanitize name (remove special characters)"""
        return re.sub(r'[^a-zA-Z0-9._-]', '_', name)

    def setup_log_directory(self):
        """Create log directory structure"""
        if not self.repo_name:
            raise ValueError("Repository name not set")

        self.log_dir = self.log_base / self.repo_name

        try:
            self.log_dir.mkdir(parents=True, exist_ok=True)
            return self.log_dir
        except PermissionError as e:
            self.log_error(f"Failed to create log directory: {self.log_dir}")
            self.log_error(f"Permission error: {e}")
            raise
        except Exception as e:
            self.log_error(f"Unexpected error creating log directory: {e}")
            raise

    def get_log_filename(self, command_name):
        """Generate log filename based on command and current date"""
        if not self.log_dir:
            raise ValueError("Log directory not set")

        date_str = datetime.now().strftime("%Y-%m-%d")
        safe_command = self._sanitize_name(command_name)
        self.log_file = self.log_dir / f"{self.log_prefix}={safe_command}={date_str}.md"
        return self.log_file

    def init_log_file(self, command_info):
        """Initialize log file with session header"""
        if not self.log_file or not self.repo_name:
            raise ValueError("Log file or repository name not set")

        current_time = datetime.now()
        command_str = ' '.join(command_info)

        # Check if this is a new file or if we're appending
        if not self.log_file.exists():
            header = f"""# Command Session Log - {self.repo_name}

**Repository:** {self.repo_name}
**Command:** `{command_str}`
**Date:** {current_time.strftime("%Y-%m-%d")}
**Started:** {current_time.strftime("%Y-%m-%d %H:%M:%S")}

---

"""
        else:
            header = f"""

---

## New Session - {current_time.strftime("%H:%M:%S")}

**Command:** `{command_str}`

"""

        try:
            with open(self.log_file, 'a', encoding='utf-8') as f:
                f.write(header)
        except Exception as e:
            self.log_error(f"Failed to initialize log file: {e}")
            raise

    def add_session_footer(self):
        """Add session footer to log file"""
        if not self.log_file:
            self.log_warn("No log file specified for session footer")
            return

        if not self.log_file.exists():
            self.log_warn("Log file does not exist for session footer")
            return

        try:
            footer = f"\n**Session ended:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
            with open(self.log_file, 'a', encoding='utf-8') as f:
                f.write(footer)
        except Exception as e:
            self.log_warn(f"Failed to add session footer: {e}")

    def check_command(self, command):
        """Check if command exists"""
        if not shutil.which(command[0]):
            self.log_error(f"{command[0]} command not found in PATH")
            self.log_error("Please ensure the command is installed and accessible")
            return False
        return True

    def cleanup(self):
        """Cleanup temporary files and add session footer"""
        # Flush any remaining buffered content to log
        self.line_buffer.flush_current_line()
        completed_lines = self.line_buffer.get_completed_lines()

        if completed_lines and self.log_file:
            try:
                with open(self.log_file, 'a', encoding='utf-8') as f:
                    f.write("```\n")
                    for line in completed_lines:
                        f.write(line + '\n')
                    f.write("```\n\n")
                self.log_success("Session logged successfully")
            except Exception as e:
                self.log_warn(f"Failed to write final log content: {e}")

        # Clean up temporary files
        for temp_file in self.temp_files:
            try:
                if temp_file.exists():
                    temp_file.unlink()
            except Exception as e:
                self.log_warn(f"Failed to cleanup temporary file {temp_file}: {e}")

        # Add session footer
        self.add_session_footer()

    def setup_signal_handlers(self):
        """Setup signal handlers for cleanup"""
        def signal_handler(signum, frame):
            self.cleanup()
            sys.exit(0)

        signal.signal(signal.SIGINT, signal_handler)
        signal.signal(signal.SIGTERM, signal_handler)

    def strip_ansi_codes(self, text):
        """Remove ANSI escape sequences from text"""
        ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
        return ansi_escape.sub('', text)

    def run_command_with_pty(self, command):
        """Run command with PTY for full TTY interaction"""
        self.log_info("Starting command session with PTY capture...")
        self.log_info(f"Command: {' '.join(command)}")
        self.log_info(f"Logging to: {self.log_file}")
        self.log_info("Note: Progress updates will be buffered and logged only when complete")

        try:
            # Create PTY
            master_fd, slave_fd = pty.openpty()

            # Start the process
            process = subprocess.Popen(
                command,
                stdin=slave_fd,
                stdout=slave_fd,
                stderr=slave_fd,
                close_fds=True,
                preexec_fn=os.setsid
            )

            os.close(slave_fd)  # Close slave fd in parent

            # Setup for select
            stdin_fd = sys.stdin.fileno()

            # Make stdin non-blocking for select
            import fcntl
            import termios
            import tty

            # Save original terminal settings
            original_settings = termios.tcgetattr(stdin_fd)
            tty.setraw(stdin_fd)

            try:
                while True:
                    # Wait for input from either stdin or master_fd
                    ready, _, _ = select.select([stdin_fd, master_fd], [], [], 0.1)

                    if stdin_fd in ready:
                        # Read from stdin and forward to master
                        try:
                            data = os.read(stdin_fd, 1024)
                            if data:
                                os.write(master_fd, data)
                        except OSError:
                            break

                    if master_fd in ready:
                        # Read from master and write to both stdout and buffer
                        try:
                            data = os.read(master_fd, 1024)
                            if data:
                                # Write to stdout (preserve colors for user)
                                sys.stdout.buffer.write(data)
                                sys.stdout.buffer.flush()

                                # Process data for logging (strip ANSI and handle \r)
                                clean_data = self.strip_ansi_codes(data.decode('utf-8', errors='ignore'))
                                self.line_buffer.add_data(clean_data)
                            else:
                                break
                        except OSError:
                            break

                    # Check if process is still running
                    if process.poll() is not None:
                        # Process finished, read any remaining data
                        try:
                            while True:
                                data = os.read(master_fd, 1024)
                                if not data:
                                    break
                                sys.stdout.buffer.write(data)
                                sys.stdout.buffer.flush()

                                clean_data = self.strip_ansi_codes(data.decode('utf-8', errors='ignore'))
                                self.line_buffer.add_data(clean_data)
                        except OSError:
                            pass
                        break

            finally:
                # Restore terminal settings
                termios.tcsetattr(stdin_fd, termios.TCSADRAIN, original_settings)
                os.close(master_fd)

            # Wait for process to complete
            return_code = process.wait()

            return return_code

        except Exception as e:
            self.log_error(f"Error running command with PTY: {e}")
            raise

    def run_command_fallback(self, command):
        """Fallback method using subprocess without PTY"""
        self.log_warn("PTY not available, using fallback method (may not capture all interactive features)")
        self.log_info(f"Command: {' '.join(command)}")
        self.log_info(f"Logging to: {self.log_file}")
        self.log_info("Note: Progress updates will be buffered and logged only when complete")

        try:
            process = subprocess.Popen(
                command,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1,
                universal_newlines=True
            )

            # Read output line by line and process it
            for line in iter(process.stdout.readline, ''):
                # Write to stdout (preserve for user)
                sys.stdout.write(line)
                sys.stdout.flush()

                # Process line for logging (strip ANSI and handle \r)
                clean_line = self.strip_ansi_codes(line)
                self.line_buffer.add_data(clean_line)

            return_code = process.wait()
            return return_code

        except Exception as e:
            self.log_error(f"Error running command with fallback method: {e}")
            raise

    def run_command_with_logging(self, command):
        """Main method to run command with logging"""
        try:
            # Try PTY method first
            if hasattr(pty, 'openpty') and hasattr(select, 'select'):
                return self.run_command_with_pty(command)
            else:
                return self.run_command_fallback(command)
        except KeyboardInterrupt:
            self.log_info("Session interrupted by user")
            return 130  # Standard exit code for SIGINT
        except Exception as e:
            self.log_error(f"Failed to run command session: {e}")
            raise
        finally:
            self.cleanup()

    def run(self, command):
        """Main entry point for running command with logging"""
        try:
            # Setup signal handlers
            self.setup_signal_handlers()

            # Check if command exists
            if not self.check_command(command):
                return 1

            # Get repository name
            repo_name = self.get_repo_name()
            if not repo_name:
                self.log_error("Failed to determine repository name")
                return 1
            self.log_info(f"Repository: {repo_name}")

            # Setup log directory
            self.setup_log_directory()

            # Get log filename
            self.get_log_filename(command[0])

            # Initialize log file
            self.init_log_file(command)

            # Run command with logging
            return self.run_command_with_logging(command)

        except Exception as e:
            self.log_error(f"Unexpected error: {e}")
            return 1


def parse_arguments():
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(
        description='Generic command wrapper with session logging',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  tee-wrap -- wasabi --thinking-token-budget 12000
  tee-wrap --log-base ~/logs -- python -i script.py
  tee-wrap --repo-name myproject -- npm start
  tee-wrap --log-prefix chat -- wasabi --enhance

The tool logs sessions to:
  <log-base>/<repo-name>/<log-prefix>=<command>=<date>.md

Default paths:
  ~/.tee-wrap/<git-repo-name>/session=<command>=<YYYY-mm-dd>.md

PROGRESS HANDLING:
  Interactive tools that overwrite lines (progress bars, status updates) are
  handled intelligently - only the final state of each line is logged, not
  every intermediate update. This prevents log spam from progress indicators.
"""
    )

    parser.add_argument(
        '--log-base',
        type=str,
        help='Base directory for logs (default: ~/.tee-wrap)'
    )

    parser.add_argument(
        '--repo-name',
        type=str,
        help='Repository name (default: auto-detected from git or directory)'
    )

    parser.add_argument(
        '--log-prefix',
        type=str,
        default='session',
        help='Log file prefix (default: session)'
    )

    parser.add_argument(
        '--quiet',
        action='store_true',
        help='Suppress info messages'
    )

    # Parse known args to handle the -- separator
    args, remaining = parser.parse_known_args()

    # Find the -- separator
    if '--' in remaining:
        separator_index = remaining.index('--')
        tee_wrap_args = remaining[:separator_index]
        command_args = remaining[separator_index + 1:]
    else:
        tee_wrap_args = remaining
        command_args = []

    # Parse any remaining tee-wrap arguments
    if tee_wrap_args:
        parser.error(f"Unrecognized arguments before '--': {' '.join(tee_wrap_args)}")

    if not command_args:
        parser.error("No command specified after '--'")

    return args, command_args


def main():
    """Main function"""
    try:
        args, command = parse_arguments()
    except SystemExit:
        return 1

    # Create logger with options
    logger = CommandLogger(
        log_base=args.log_base,
        repo_name=args.repo_name,
        log_prefix=args.log_prefix
    )

    # Suppress info messages if requested
    if args.quiet:
        logger.log_info = lambda x: None

    return logger.run(command)


if __name__ == "__main__":
    sys.exit(main())
