#!/usr/bin/env python3
"""
Bridge between stdio and Unix domain socket for MCP communication.
Reads from stdin, forwards to socket. Reads from socket, forwards to stdout.

Automatically detects the correct neovim socket based on NVIM_PARENT_PID.

Usage:
  nvim-mcp-bridge

Environment Variables:
  NVIM_SOCKET_PATH: Path to Unix domain socket (overrides auto-detection)
  NVIM_PARENT_PID: Parent Neovim PID (injected by term-popup plugin)
"""

import socket
import sys
import os
import threading


def get_auto_socket_path():
    """Automatically determine socket path based on parent Neovim process.

    Uses NVIM_PARENT_PID environment variable injected by term-popup plugin
    to identify the correct Neovim instance, avoiding cross-instance issues
    with nested terminals.
    """
    # Get NVIM_PARENT_PID environment variable
    nvim_pid = os.environ.get('NVIM_PARENT_PID')

    if not nvim_pid:
        raise RuntimeError(
            "NVIM_PARENT_PID environment variable not found.\n"
            "This tool must be run from within a Neovim :terminal session.\n"
            "Make sure the term-popup plugin is loaded."
        )

    # Always use PID-based socket (deterministic, no fallbacks)
    socket_path = f"/tmp/radish-nvim-pid-{nvim_pid}.sock"
    if not os.path.exists(socket_path):
        raise RuntimeError(
            f"Neovim socket not found for PID {nvim_pid}.\n"
            f"Expected: {socket_path}\n"
            f"Make sure the radish-mcp plugin is loaded in Neovim."
        )

    return socket_path


def stdio_to_socket(sock):
    """Read from stdin and write to socket."""
    try:
        while True:
            # Read from stdin
            line = sys.stdin.buffer.readline()
            if not line:
                break
            sock.sendall(line)
    except (BrokenPipeError, ConnectionError, OSError):
        pass
    finally:
        try:
            sock.close()
        except:
            pass


def socket_to_stdio(sock):
    """Read from socket and write to stdout."""
    try:
        while True:
            data = sock.recv(4096)
            if not data:
                break
            sys.stdout.buffer.write(data)
            sys.stdout.buffer.flush()
    except (BrokenPipeError, ConnectionError, OSError):
        pass


def main():
    # Try to get socket path from environment first, then auto-detect
    socket_path = os.environ.get('NVIM_SOCKET_PATH')

    if not socket_path:
        try:
            socket_path = get_auto_socket_path()
        except RuntimeError as e:
            print(f"Error: {e}", file=sys.stderr)
            sys.exit(1)

    # Create Unix domain socket
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)

    try:
        sock.connect(socket_path)
    except FileNotFoundError:
        print(f"Error: Socket not found at {socket_path}", file=sys.stderr)
        print(f"Make sure Neovim is running with the radish-mcp-server plugin loaded", file=sys.stderr)
        sys.exit(1)
    except ConnectionRefusedError:
        print(f"Error: Connection refused to {socket_path}", file=sys.stderr)
        print(f"The socket exists but nothing is listening on it", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error connecting to socket: {e}", file=sys.stderr)
        sys.exit(1)

    # Print debug info to stderr (won't interfere with stdio communication)
    print(f"Connected to neovim at: {socket_path}", file=sys.stderr)

    # Start bidirectional forwarding
    # Use thread for stdin->socket so we can handle both directions
    stdin_thread = threading.Thread(target=stdio_to_socket, args=(sock,), daemon=True)
    stdin_thread.start()

    # Run socket->stdout in main thread
    socket_to_stdio(sock)

    # Wait for stdin thread to finish
    stdin_thread.join(timeout=1)

    try:
        sock.close()
    except:
        pass


if __name__ == '__main__':
    main()
